{
	"$schema": "https://shadcn-svelte.com/schema/registry-item.json",
	"name": "form",
	"type": "registry:ui",
	"dependencies": [
		"@tanstack/svelte-form"
	],
	"registryDependencies": [
		"label"
	],
	"files": [
		{
			"content": "export { default as Form } from './form.svelte';\nexport { default as FormLabel } from './form-label.svelte';\nexport { default as FieldErrors } from './form-field-error.svelte';\nexport { default as FormArray } from './form-array.svelte';\nexport {\n    FieldContent as FormContent,\n    FieldSet as FormSet,\n    FieldLegend as FormLegend,\n    FieldTitle as FormTitle,\n    Field as FormField,\n    FieldDescription as FormDescription,\n    FieldSeparator as FormSeparator\n} from '$lib/components/ui/field';\nexport type { BaseInputProps, FieldType, FormContext, GenericInputProps } from './form-context.svelte.ts';\n",
			"type": "registry:file",
			"target": "form/index.ts"
		},
		{
			"content": "<script lang=\"ts\" generics=\"T\">\n    import type { Snippet } from 'svelte';\n    import type { BaseInputProps } from './form-context.svelte';\n    import type { DeepKeys } from '@tanstack/svelte-form';\n\n    let {\n        property,\n        context,\n        template,\n        ...restProps\n    }: { template: Snippet<[DeepKeys<T>]> } & BaseInputProps<T> = $props();\n\n    const form = context.form;\n\n    function GetIndexFieldName(\n        property: DeepKeys<T>,\n        index: number\n    ): DeepKeys<T> {\n        return property + '[' + index + ']';\n    }\n</script>\n\n<form.Field name={property} mode=\"array\">\n    {#snippet children(field)}\n        {#each field.state.value as ArrayLike<unknown> as _, i}\n            {@render template?.(GetIndexFieldName(property, i))}\n        {/each}\n    {/snippet}\n</form.Field>\n",
			"type": "registry:file",
			"target": "form/form-array.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"T\">\n    import { FieldError } from '$lib/components/ui/field';\n    import type { BaseInputProps, FieldType } from './form-context.svelte';\n\n    let { field, errorClass }: { field: FieldType<T> } & BaseInputProps<T> =\n        $props();\n</script>\n\n<FieldError errors={field.state.meta.errors} class={errorClass} />\n",
			"type": "registry:file",
			"target": "form/form-field-error.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"T\">\n    import { FieldLabel } from '$lib/components/ui/field';\n    import { cn } from '$UTILS$';\n    import type { Snippet } from 'svelte';\n    import type { BaseInputProps, FieldType } from './form-context.svelte';\n\n    let {\n        field,\n        label,\n        labelClass,\n        required,\n        children,\n    }: {\n        field: FieldType<T>;\n        required?: boolean | null | undefined;\n        children?: Snippet<[]>;\n    } & BaseInputProps<T> = $props();\n</script>\n\n<FieldLabel\n    for={field.name}\n    class={cn('group-aria-[invalid=true]/field:text-destructive', labelClass)}\n>\n    {#if children}\n        {@render children?.()}\n    {:else}\n        {label}\n        {#if required}\n            *\n        {/if}\n    {/if}\n</FieldLabel>\n",
			"type": "registry:file",
			"target": "form/form-label.svelte"
		},
		{
			"content": "<script lang=\"ts\" generics=\"T\">\n    import { FormContext, type FormProps } from './form-context.svelte';\n\n    let props: FormProps<T> = $props();\n    const context = new FormContext(props);\n\n    //TODO:\n    //Nice to have:\n    // - combox (I decided not to do this is as all are bit different, I might make a generic one for simple cases)\n    // - error summary???\n    // - time picker\n    // - date range picker\n    // - tag input\n    // - phone\n    // - slider\n    // - location\n    // - input OTP\n</script>\n\n<form\n    onsubmit={(e) => {\n        e.preventDefault();\n        e.stopPropagation();\n        context.form.handleSubmit();\n    }}\n    class={'flex flex-col gap-4'}\n    novalidate={props.enableBrowserValidation ?? true}\n>\n    {@render props.fields?.(context)}\n</form>\n",
			"type": "registry:file",
			"target": "form/form.svelte"
		},
		{
			"content": "import type {\n    StandardSchemaV1,\n    StandardSchemaV1Issue,\n} from '@tanstack/svelte-form';\nimport type { Validator, AsyncValidator } from 'fluentvalidation-ts';\n\nfunction collectIssues(\n    node: unknown,\n    path: Array<PropertyKey> = [],\n    into: Array<StandardSchemaV1Issue> = []\n): Array<StandardSchemaV1Issue> {\n    if (node == null) return into;\n\n    if (typeof node === 'string') {\n        into.push({ message: node, path: path.length ? [...path] : undefined });\n        return into;\n    }\n\n    if (Array.isArray(node)) {\n        node.forEach((child, i) => {\n            if (child != null) collectIssues(child as any, [...path, i], into);\n        });\n        return into;\n    }\n\n    if (typeof node === 'object') {\n        for (const [k, v] of Object.entries(node as Record<string, unknown>)) {\n            if (v != null) collectIssues(v, [...path, k], into);\n        }\n        return into;\n    }\n\n    return into;\n}\n\nexport function standardFromFluent<T>(\n    validator: Validator<T>\n): StandardSchemaV1<T> {\n    return {\n        '~standard': {\n            version: 1,\n            vendor: 'fluentvalidation-ts',\n            validate(value: unknown) {\n                // We trust caller to give T at runtime; FV will compute errors.\n                const errors = (validator as Validator<T>).validate(value as T);\n                const issues = collectIssues(errors);\n                return issues.length === 0 ? { value: value as T } : { issues };\n            },\n            types: undefined as unknown as StandardSchemaV1.Types<T, T>,\n        },\n    };\n}\n\nexport function standardFromFluentAsync<T>(\n    validator: AsyncValidator<T>\n): StandardSchemaV1<T> {\n    return {\n        '~standard': {\n            version: 1,\n            vendor: 'fluentvalidation-ts',\n            async validate(value: unknown) {\n                const errors = await (\n                    validator as AsyncValidator<T>\n                ).validateAsync(value as T);\n                const issues = collectIssues(errors);\n                return issues.length === 0 ? { value: value as T } : { issues };\n            },\n            types: undefined as unknown as StandardSchemaV1.Types<T, T>,\n        },\n    };\n}\n",
			"type": "registry:lib",
			"target": "fluentvalidation-adapter.ts"
		}
	]
}